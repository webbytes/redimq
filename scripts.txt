Add messageGroup:

#!lua name=queueLib
local maxMessageGroups = 10000

local function addMessageGroup(keys, args)

	-- check if messageGroup exists in list
	if redis.call("LPOS", keys[1], args[1]) == nil then

		-- check if count of messageGroups is more than maxMessageGroups var
		if redis.call("LLEN", keys[1]) == maxMessageGroups then
			redis.call("LPOP", keys[1])
		end
		
		-- add to list and stream
		redis.call("LPUSH", keys[1], args[1]) 
		redis.call("XADD", "keys[2], "MAXLEN", "~", maxMessageGroups, "*", "messageGroupkey",args[1])
	end
end
redis.register_function('addMessageGroup', addMessageGroup)
--FCALL addMessageGroup 2 queue:activemessageGroups queue:messageGroups INC10001212121 

Add Message:
XADD queue:messages:MESSAGE_KEY MAXLEN ~ 10000 * <...data>

Lock MessageGroup:
#!lua name=queueLib
local maxMessageGroupIdleTime = 5 * 60 * 1000 -- 5 mins

local function getMessageGroup(keys, args)
 	local group = args[1]
	local worker = args[2]

	-- Get free messageGroup
 	local messageGroup = redis.call("XREADGROUP", "GROUP", group, worker, "COUNT", "1", "STREAMS", keys[1], ">")
	if messageGroup == nil then
   		-- Get messageGroups (older than maxMessageGroupsIdleTime) from PEL if not free available
		return redis.call("XAUTOCLAIM", keys[1], group, worker, maxMessageGroupIdleTime, "0-0", "COUNT", "1")
	else
		return messageGroup
	end 
end
redis.register_function('getMessageGroup', getMessageGroup)
--FCALL getMessageGroup 1 queue:messageGroups ir-postprocess ir-postprocess-1

Lock Message:
#!lua name=queueLib
maxIdleTime = 1
local function getMessage(keys, args)
	local group = args[1]
	local worker = args[2]

	-- reset idle time on messageGroup while getting a new message
	redis.call("XCLAIM", keys[2], group, worker, 1, args[3], "RETRYCOUNT", "0")
	
	-- Get messages from PEL first since they are older
	local msg = redis.call("XAUTOCLAIM", keys[1], group, worker, maxIdleTime, "0-0", "COUNT", "1")

	-- Get normal messages if none in PEL
	if msg == nil then
		return redis.call("XREADGROUP", "GROUP", group, worker, "COUNT", "1", "STREAMS", keys[1], ">")
	else 
		return msg
	end
end
redis.register_function('getMessage', getMessage)
--FCALL getMessage 2 queue:messages:<SESSION_KEY:INC1000011212> queue:messageGroups <WORKER_GROUP:ir-post-process> <WORKER_ID:ir-post-process-1> <SESSION_ID:1234567890-1>

Update message to complete:
XACK queue:messages:<SESSIONKEY:INC100111212121> <WORKER_GROUP:ir-post-process> <MESSAGE_ID:1234567890-1>

Unlock MessageGroup:
#!lua name=queueLib
local function removeMessageGroup(keys, args)
	redis.call("LREM", keys[1], "1", args[1]) 
	redis.call("XDEL", "keys[2],args[1])
end
redis.register_function('removeMessageGroup', removeMessageGroup)
--FCALL removeMessageGroup 2 queue:activemessageGroups queue:messageGroups <MESSAGE_ID:1234567890-1>

DeadLetter :
LLEN queue:activemessageGroups
LRANGE queue:activemessageGroups 0 <SESSIONS_COUNT>
For each messageGroup
	Do While no Data returned
		XPENDING queue:messages:<SESSION_KEY> <WORKER_GROUP> IDLE maxMessageGroupIdleTime - + 100
		For each message
			IF message.retrycount > <THRESHOLD>
				msg = XRANGE queue:messages:<SESSION_KEY> message.ID + COUNT 1
				HSET queue:deadletter:<WORKER_GROUP>:<SESSION_KEY>:<message.ID> ...message.data
				XDEL queue:messages:<SESSION_KEY> message.ID
			END IF
		End For
	End Do
End For

Delete old messages:
Not required for Redis since it implements retention by count of messages per messageGroup instead of duration
